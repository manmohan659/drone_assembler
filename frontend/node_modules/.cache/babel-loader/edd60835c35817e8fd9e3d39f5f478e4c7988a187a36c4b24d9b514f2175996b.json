{"ast":null,"code":"var _s = $RefreshSig$();\n// frontend/src/components/SpeechHandler.js\nimport React, { useEffect, useCallback, useRef } from 'react';\nimport Logger from '../utils/logger';\nconst SpeechHandler = ({\n  text,\n  onSpeechEnd,\n  autoSpeak = true\n}) => {\n  _s();\n  // Use a ref to track if component is mounted\n  const isMounted = useRef(true);\n  // Track if we're currently speaking\n  const isSpeaking = useRef(false);\n  // Keep the latest text to speak\n  const textToSpeak = useRef('');\n\n  // Process text to make it more suitable for speech\n  const processTextForSpeech = text => {\n    if (!text) return '';\n\n    // If the text looks like JSON, try to extract useful parts\n    if (text && (text.includes('{') || text.includes('```'))) {\n      try {\n        // Clean any markdown formatting\n        const cleanedText = text.replace(/```json/g, '').replace(/```/g, '').trim();\n\n        // Try to parse as JSON\n        const jsonData = JSON.parse(cleanedText);\n\n        // Extract human-readable content based on available fields\n        let speechText = '';\n        if (jsonData.answer) {\n          speechText += jsonData.answer + ' ';\n        }\n        if (jsonData.details) {\n          speechText += jsonData.details + ' ';\n        }\n        if (jsonData.feedback) {\n          speechText += jsonData.feedback + ' ';\n        }\n        if (jsonData.warnings && jsonData.warnings.length > 0) {\n          speechText += 'Warnings: ' + jsonData.warnings.join('. ') + ' ';\n        }\n        if (jsonData.recommendations && jsonData.recommendations.length > 0) {\n          speechText += 'Recommendations: ' + jsonData.recommendations.join('. ') + ' ';\n        }\n        if (jsonData.nextSteps && jsonData.nextSteps.length > 0) {\n          speechText += 'Next steps: ' + jsonData.nextSteps.join('. ') + ' ';\n        }\n        return speechText.trim() || text;\n      } catch (error) {\n        Logger.error('Failed to parse JSON for speech:', error);\n        return text;\n      }\n    }\n    return text;\n  };\n\n  // Initialize speech synthesis\n  const initSpeechSynthesis = useCallback(() => {\n    // Check if speech synthesis is already initialized\n    if (!window.speechSynthesis) {\n      Logger.error('Speech synthesis not supported in this browser');\n      return false;\n    }\n    return true;\n  }, []);\n\n  // The speak function now uses a more reliable approach\n  const speak = useCallback(rawText => {\n    if (!rawText || isSpeaking.current) return;\n    if (!initSpeechSynthesis()) return;\n\n    // Process the text to make it suitable for speech\n    const processedText = processTextForSpeech(rawText);\n    if (!processedText) return;\n    isSpeaking.current = true;\n\n    // Always cancel any ongoing speech first\n    try {\n      window.speechSynthesis.cancel();\n    } catch (e) {\n      Logger.error('Error canceling previous speech:', e);\n    }\n\n    // Short timeout to ensure cancel completes\n    setTimeout(() => {\n      try {\n        const utterance = new SpeechSynthesisUtterance(processedText);\n\n        // Log the speech start\n        Logger.info('Starting speech synthesis:', {\n          processedText: processedText.slice(0, 100) + (processedText.length > 100 ? '...' : '')\n        });\n        utterance.onend = () => {\n          Logger.info('Speech synthesis completed');\n          isSpeaking.current = false;\n          if (isMounted.current && onSpeechEnd) onSpeechEnd();\n\n          // Check if there's new text to speak\n          if (textToSpeak.current && textToSpeak.current !== processedText) {\n            const nextText = textToSpeak.current;\n            textToSpeak.current = '';\n            speak(nextText);\n          }\n        };\n        utterance.onerror = error => {\n          Logger.error('Speech synthesis error:', error);\n          isSpeaking.current = false;\n\n          // Try again with a simpler approach on error\n          if (error.error === 'canceled' && isMounted.current) {\n            Logger.info('Retrying speech with a simpler approach');\n            // Use a simpler speech approach as fallback\n            try {\n              const simpleUtterance = new SpeechSynthesisUtterance(processedText.slice(0, 500) // Limit text length\n              );\n              window.speechSynthesis.speak(simpleUtterance);\n            } catch (e) {\n              Logger.error('Fallback speech synthesis failed:', e);\n            }\n          }\n        };\n\n        // Set rate slightly slower for better comprehension\n        utterance.rate = 0.9;\n\n        // Start speaking\n        window.speechSynthesis.speak(utterance);\n      } catch (error) {\n        Logger.error('Failed to start speech synthesis:', error);\n        isSpeaking.current = false;\n      }\n    }, 100);\n  }, [initSpeechSynthesis, onSpeechEnd]);\n\n  // Effect for initial speech and cleanup\n  useEffect(() => {\n    // Set mounted flag\n    isMounted.current = true;\n\n    // Initialize speech synthesis\n    initSpeechSynthesis();\n\n    // Cleanup function\n    return () => {\n      isMounted.current = false;\n      // Cancel any ongoing speech when component unmounts\n      try {\n        window.speechSynthesis.cancel();\n      } catch (e) {\n        // Ignore errors during cleanup\n      }\n    };\n  }, [initSpeechSynthesis]);\n\n  // Effect to handle text changes\n  useEffect(() => {\n    if (autoSpeak && text) {\n      if (isSpeaking.current) {\n        // If already speaking, store the text for later\n        textToSpeak.current = text;\n        // Cancel current speech to start the new one sooner\n        try {\n          window.speechSynthesis.cancel();\n        } catch (e) {\n          // Ignore errors\n        }\n      } else {\n        // If not speaking, speak immediately\n        speak(text);\n      }\n    }\n  }, [text, autoSpeak, speak]);\n  return null; // This is a non-visual component\n};\n_s(SpeechHandler, \"zih+htxjRf1FyD1B7xx2Ke1/PSA=\");\n_c = SpeechHandler;\nexport default SpeechHandler;\nvar _c;\n$RefreshReg$(_c, \"SpeechHandler\");","map":{"version":3,"names":["React","useEffect","useCallback","useRef","Logger","SpeechHandler","text","onSpeechEnd","autoSpeak","_s","isMounted","isSpeaking","textToSpeak","processTextForSpeech","includes","cleanedText","replace","trim","jsonData","JSON","parse","speechText","answer","details","feedback","warnings","length","join","recommendations","nextSteps","error","initSpeechSynthesis","window","speechSynthesis","speak","rawText","current","processedText","cancel","e","setTimeout","utterance","SpeechSynthesisUtterance","info","slice","onend","nextText","onerror","simpleUtterance","rate","_c","$RefreshReg$"],"sources":["/Users/manmohan/drone-assembly-ai/frontend/src/components/SpeechHandler.js"],"sourcesContent":["// frontend/src/components/SpeechHandler.js\nimport React, { useEffect, useCallback, useRef } from 'react';\nimport Logger from '../utils/logger';\n\nconst SpeechHandler = ({ text, onSpeechEnd, autoSpeak = true }) => {\n  // Use a ref to track if component is mounted\n  const isMounted = useRef(true);\n  // Track if we're currently speaking\n  const isSpeaking = useRef(false);\n  // Keep the latest text to speak\n  const textToSpeak = useRef('');\n  \n  // Process text to make it more suitable for speech\n  const processTextForSpeech = (text) => {\n    if (!text) return '';\n    \n    // If the text looks like JSON, try to extract useful parts\n    if (text && (text.includes('{') || text.includes('```'))) {\n      try {\n        // Clean any markdown formatting\n        const cleanedText = text\n          .replace(/```json/g, '')\n          .replace(/```/g, '')\n          .trim();\n          \n        // Try to parse as JSON\n        const jsonData = JSON.parse(cleanedText);\n        \n        // Extract human-readable content based on available fields\n        let speechText = '';\n        \n        if (jsonData.answer) {\n          speechText += jsonData.answer + ' ';\n        }\n        \n        if (jsonData.details) {\n          speechText += jsonData.details + ' ';\n        }\n        \n        if (jsonData.feedback) {\n          speechText += jsonData.feedback + ' ';\n        }\n        \n        if (jsonData.warnings && jsonData.warnings.length > 0) {\n          speechText += 'Warnings: ' + jsonData.warnings.join('. ') + ' ';\n        }\n        \n        if (jsonData.recommendations && jsonData.recommendations.length > 0) {\n          speechText += 'Recommendations: ' + jsonData.recommendations.join('. ') + ' ';\n        }\n        \n        if (jsonData.nextSteps && jsonData.nextSteps.length > 0) {\n          speechText += 'Next steps: ' + jsonData.nextSteps.join('. ') + ' ';\n        }\n        \n        return speechText.trim() || text;\n      } catch (error) {\n        Logger.error('Failed to parse JSON for speech:', error);\n        return text;\n      }\n    }\n    \n    return text;\n  };\n\n  // Initialize speech synthesis\n  const initSpeechSynthesis = useCallback(() => {\n    // Check if speech synthesis is already initialized\n    if (!window.speechSynthesis) {\n      Logger.error('Speech synthesis not supported in this browser');\n      return false;\n    }\n    \n    return true;\n  }, []);\n\n  // The speak function now uses a more reliable approach\n  const speak = useCallback((rawText) => {\n    if (!rawText || isSpeaking.current) return;\n    \n    if (!initSpeechSynthesis()) return;\n    \n    // Process the text to make it suitable for speech\n    const processedText = processTextForSpeech(rawText);\n    if (!processedText) return;\n    \n    isSpeaking.current = true;\n    \n    // Always cancel any ongoing speech first\n    try {\n      window.speechSynthesis.cancel();\n    } catch (e) {\n      Logger.error('Error canceling previous speech:', e);\n    }\n    \n    // Short timeout to ensure cancel completes\n    setTimeout(() => {\n      try {\n        const utterance = new SpeechSynthesisUtterance(processedText);\n        \n        // Log the speech start\n        Logger.info('Starting speech synthesis:', { \n          processedText: processedText.slice(0, 100) + (processedText.length > 100 ? '...' : '')\n        });\n        \n        utterance.onend = () => {\n          Logger.info('Speech synthesis completed');\n          isSpeaking.current = false;\n          if (isMounted.current && onSpeechEnd) onSpeechEnd();\n          \n          // Check if there's new text to speak\n          if (textToSpeak.current && textToSpeak.current !== processedText) {\n            const nextText = textToSpeak.current;\n            textToSpeak.current = '';\n            speak(nextText);\n          }\n        };\n        \n        utterance.onerror = (error) => {\n          Logger.error('Speech synthesis error:', error);\n          isSpeaking.current = false;\n          \n          // Try again with a simpler approach on error\n          if (error.error === 'canceled' && isMounted.current) {\n            Logger.info('Retrying speech with a simpler approach');\n            // Use a simpler speech approach as fallback\n            try {\n              const simpleUtterance = new SpeechSynthesisUtterance(\n                processedText.slice(0, 500) // Limit text length\n              );\n              window.speechSynthesis.speak(simpleUtterance);\n            } catch (e) {\n              Logger.error('Fallback speech synthesis failed:', e);\n            }\n          }\n        };\n        \n        // Set rate slightly slower for better comprehension\n        utterance.rate = 0.9;\n        \n        // Start speaking\n        window.speechSynthesis.speak(utterance);\n      } catch (error) {\n        Logger.error('Failed to start speech synthesis:', error);\n        isSpeaking.current = false;\n      }\n    }, 100);\n  }, [initSpeechSynthesis, onSpeechEnd]);\n\n  // Effect for initial speech and cleanup\n  useEffect(() => {\n    // Set mounted flag\n    isMounted.current = true;\n    \n    // Initialize speech synthesis\n    initSpeechSynthesis();\n    \n    // Cleanup function\n    return () => {\n      isMounted.current = false;\n      // Cancel any ongoing speech when component unmounts\n      try {\n        window.speechSynthesis.cancel();\n      } catch (e) {\n        // Ignore errors during cleanup\n      }\n    };\n  }, [initSpeechSynthesis]);\n\n  // Effect to handle text changes\n  useEffect(() => {\n    if (autoSpeak && text) {\n      if (isSpeaking.current) {\n        // If already speaking, store the text for later\n        textToSpeak.current = text;\n        // Cancel current speech to start the new one sooner\n        try {\n          window.speechSynthesis.cancel();\n        } catch (e) {\n          // Ignore errors\n        }\n      } else {\n        // If not speaking, speak immediately\n        speak(text);\n      }\n    }\n  }, [text, autoSpeak, speak]);\n\n  return null; // This is a non-visual component\n};\n\nexport default SpeechHandler;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
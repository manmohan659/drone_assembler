{"ast":null,"code":"var _s = $RefreshSig$();\n// frontend/src/components/SpeechHandler.js\nimport React, { useEffect, useCallback, useRef } from 'react';\nimport Logger from '../utils/logger';\nconst SpeechHandler = ({\n  text,\n  onSpeechEnd,\n  autoSpeak = true\n}) => {\n  _s();\n  // Use a ref to track if component is mounted\n  const isMounted = useRef(true);\n  // Track if we're currently speaking\n  const isSpeaking = useRef(false);\n  // Track the current utterance's request ID to avoid duplicates\n  const currentRequestId = useRef(null);\n  // Store last spoken text to avoid repeating the same text\n  const lastSpokenText = useRef('');\n\n  // Process text to make it more suitable for speech\n  const processTextForSpeech = text => {\n    if (!text) return '';\n\n    // If the text looks like JSON, try to extract useful parts\n    if (text && (text.includes('{') || text.includes('```'))) {\n      try {\n        // Clean any markdown formatting\n        const cleanedText = text.replace(/```json/g, '').replace(/```/g, '').trim();\n\n        // Try to parse as JSON\n        const jsonData = JSON.parse(cleanedText);\n\n        // Extract human-readable content based on available fields\n        let speechText = '';\n        if (jsonData.answer) {\n          speechText += jsonData.answer + ' ';\n        }\n        if (jsonData.details) {\n          speechText += jsonData.details + ' ';\n        }\n        if (jsonData.feedback) {\n          speechText += jsonData.feedback + ' ';\n        }\n        if (jsonData.warnings && jsonData.warnings.length > 0) {\n          speechText += 'Warnings: ' + jsonData.warnings.join('. ') + ' ';\n        }\n        if (jsonData.recommendations && jsonData.recommendations.length > 0) {\n          speechText += 'Recommendations: ' + jsonData.recommendations.join('. ') + ' ';\n        }\n        if (jsonData.nextSteps && jsonData.nextSteps.length > 0) {\n          speechText += 'Next steps: ' + jsonData.nextSteps.join('. ') + ' ';\n        }\n        return speechText.trim() || text;\n      } catch (error) {\n        Logger.error('Failed to parse JSON for speech:', error);\n        return text;\n      }\n    }\n    return text;\n  };\n\n  // Initialize speech synthesis\n  const initSpeechSynthesis = useCallback(() => {\n    // Check if speech synthesis is already initialized\n    if (!window.speechSynthesis) {\n      Logger.error('Speech synthesis not supported in this browser');\n      return false;\n    }\n    return true;\n  }, []);\n\n  // Cancel any ongoing speech\n  const cancelSpeech = useCallback(() => {\n    try {\n      if (window.speechSynthesis) {\n        window.speechSynthesis.cancel();\n        Logger.info('Speech synthesis canceled');\n      }\n    } catch (e) {\n      Logger.error('Error canceling speech:', e);\n    }\n    isSpeaking.current = false;\n  }, []);\n\n  // The speak function now uses a more reliable approach with duplicate prevention\n  const speak = useCallback(rawText => {\n    if (!rawText) return;\n    if (!initSpeechSynthesis()) return;\n\n    // Process the text to make it suitable for speech\n    const processedText = processTextForSpeech(rawText);\n    if (!processedText) return;\n\n    // Check if this is the same as the last spoken text - prevent duplicates\n    if (processedText === lastSpokenText.current) {\n      Logger.info('Skipping duplicate speech text');\n      return;\n    }\n\n    // Generate a unique request ID for this speech request\n    const requestId = Date.now().toString();\n\n    // Always cancel any ongoing speech first \n    cancelSpeech();\n\n    // Short timeout to ensure cancel completes\n    setTimeout(() => {\n      try {\n        // Set speaking state and update tracking variables\n        isSpeaking.current = true;\n        currentRequestId.current = requestId;\n        lastSpokenText.current = processedText;\n        const utterance = new SpeechSynthesisUtterance(processedText);\n\n        // Add unique identifier \n        utterance.requestId = requestId;\n\n        // Log the speech start\n        Logger.info('Starting speech synthesis:', {\n          processedText: processedText.slice(0, 100) + (processedText.length > 100 ? '...' : ''),\n          requestId\n        });\n        utterance.onend = () => {\n          // Only process end event for the current request\n          if (utterance.requestId === currentRequestId.current) {\n            Logger.info('Speech synthesis completed', {\n              requestId: utterance.requestId\n            });\n            isSpeaking.current = false;\n            currentRequestId.current = null;\n            if (isMounted.current && onSpeechEnd) onSpeechEnd();\n          } else {\n            Logger.info('Ignoring completed event for outdated speech request', {\n              requestId: utterance.requestId,\n              currentRequestId: currentRequestId.current\n            });\n          }\n        };\n        utterance.onerror = error => {\n          Logger.error('Speech synthesis error:', error);\n          isSpeaking.current = false;\n          currentRequestId.current = null;\n        };\n\n        // Set rate slightly slower for better comprehension\n        utterance.rate = 0.9;\n\n        // Start speaking\n        window.speechSynthesis.speak(utterance);\n      } catch (error) {\n        Logger.error('Failed to start speech synthesis:', error);\n        isSpeaking.current = false;\n        currentRequestId.current = null;\n      }\n    }, 100);\n  }, [initSpeechSynthesis, cancelSpeech, onSpeechEnd]);\n\n  // Effect for initial speech and cleanup\n  useEffect(() => {\n    // Set mounted flag\n    isMounted.current = true;\n\n    // Initialize speech synthesis\n    initSpeechSynthesis();\n\n    // Cleanup function\n    return () => {\n      isMounted.current = false;\n      // Cancel any ongoing speech when component unmounts\n      cancelSpeech();\n    };\n  }, [initSpeechSynthesis, cancelSpeech]);\n\n  // Effect to handle text changes with proper cleanup\n  useEffect(() => {\n    if (autoSpeak && text) {\n      // If text changed, cancel any current speech and speak the new text\n      cancelSpeech();\n\n      // Small delay to ensure cancellation is complete\n      setTimeout(() => {\n        speak(text);\n      }, 150);\n    }\n\n    // If text is cleared, cancel any ongoing speech\n    if (!text) {\n      cancelSpeech();\n    }\n  }, [text, autoSpeak, speak, cancelSpeech]);\n  return null; // This is a non-visual component\n};\n_s(SpeechHandler, \"pLOvxg5+fuUKFSjTYgOQ50NqEvI=\");\n_c = SpeechHandler;\nexport default SpeechHandler;\nvar _c;\n$RefreshReg$(_c, \"SpeechHandler\");","map":{"version":3,"names":["React","useEffect","useCallback","useRef","Logger","SpeechHandler","text","onSpeechEnd","autoSpeak","_s","isMounted","isSpeaking","currentRequestId","lastSpokenText","processTextForSpeech","includes","cleanedText","replace","trim","jsonData","JSON","parse","speechText","answer","details","feedback","warnings","length","join","recommendations","nextSteps","error","initSpeechSynthesis","window","speechSynthesis","cancelSpeech","cancel","info","e","current","speak","rawText","processedText","requestId","Date","now","toString","setTimeout","utterance","SpeechSynthesisUtterance","slice","onend","onerror","rate","_c","$RefreshReg$"],"sources":["/Users/manmohan/drone-assembly-ai/frontend/src/components/SpeechHandler.js"],"sourcesContent":["// frontend/src/components/SpeechHandler.js\nimport React, { useEffect, useCallback, useRef } from 'react';\nimport Logger from '../utils/logger';\n\nconst SpeechHandler = ({ text, onSpeechEnd, autoSpeak = true }) => {\n  // Use a ref to track if component is mounted\n  const isMounted = useRef(true);\n  // Track if we're currently speaking\n  const isSpeaking = useRef(false);\n  // Track the current utterance's request ID to avoid duplicates\n  const currentRequestId = useRef(null);\n  // Store last spoken text to avoid repeating the same text\n  const lastSpokenText = useRef('');\n  \n  // Process text to make it more suitable for speech\n  const processTextForSpeech = (text) => {\n    if (!text) return '';\n    \n    // If the text looks like JSON, try to extract useful parts\n    if (text && (text.includes('{') || text.includes('```'))) {\n      try {\n        // Clean any markdown formatting\n        const cleanedText = text\n          .replace(/```json/g, '')\n          .replace(/```/g, '')\n          .trim();\n          \n        // Try to parse as JSON\n        const jsonData = JSON.parse(cleanedText);\n        \n        // Extract human-readable content based on available fields\n        let speechText = '';\n        \n        if (jsonData.answer) {\n          speechText += jsonData.answer + ' ';\n        }\n        \n        if (jsonData.details) {\n          speechText += jsonData.details + ' ';\n        }\n        \n        if (jsonData.feedback) {\n          speechText += jsonData.feedback + ' ';\n        }\n        \n        if (jsonData.warnings && jsonData.warnings.length > 0) {\n          speechText += 'Warnings: ' + jsonData.warnings.join('. ') + ' ';\n        }\n        \n        if (jsonData.recommendations && jsonData.recommendations.length > 0) {\n          speechText += 'Recommendations: ' + jsonData.recommendations.join('. ') + ' ';\n        }\n        \n        if (jsonData.nextSteps && jsonData.nextSteps.length > 0) {\n          speechText += 'Next steps: ' + jsonData.nextSteps.join('. ') + ' ';\n        }\n        \n        return speechText.trim() || text;\n      } catch (error) {\n        Logger.error('Failed to parse JSON for speech:', error);\n        return text;\n      }\n    }\n    \n    return text;\n  };\n\n  // Initialize speech synthesis\n  const initSpeechSynthesis = useCallback(() => {\n    // Check if speech synthesis is already initialized\n    if (!window.speechSynthesis) {\n      Logger.error('Speech synthesis not supported in this browser');\n      return false;\n    }\n    \n    return true;\n  }, []);\n\n  // Cancel any ongoing speech\n  const cancelSpeech = useCallback(() => {\n    try {\n      if (window.speechSynthesis) {\n        window.speechSynthesis.cancel();\n        Logger.info('Speech synthesis canceled');\n      }\n    } catch (e) {\n      Logger.error('Error canceling speech:', e);\n    }\n    isSpeaking.current = false;\n  }, []);\n\n  // The speak function now uses a more reliable approach with duplicate prevention\n  const speak = useCallback((rawText) => {\n    if (!rawText) return;\n    \n    if (!initSpeechSynthesis()) return;\n    \n    // Process the text to make it suitable for speech\n    const processedText = processTextForSpeech(rawText);\n    if (!processedText) return;\n    \n    // Check if this is the same as the last spoken text - prevent duplicates\n    if (processedText === lastSpokenText.current) {\n      Logger.info('Skipping duplicate speech text');\n      return;\n    }\n    \n    // Generate a unique request ID for this speech request\n    const requestId = Date.now().toString();\n    \n    // Always cancel any ongoing speech first \n    cancelSpeech();\n    \n    // Short timeout to ensure cancel completes\n    setTimeout(() => {\n      try {\n        // Set speaking state and update tracking variables\n        isSpeaking.current = true;\n        currentRequestId.current = requestId;\n        lastSpokenText.current = processedText;\n        \n        const utterance = new SpeechSynthesisUtterance(processedText);\n        \n        // Add unique identifier \n        utterance.requestId = requestId;\n        \n        // Log the speech start\n        Logger.info('Starting speech synthesis:', { \n          processedText: processedText.slice(0, 100) + (processedText.length > 100 ? '...' : ''),\n          requestId\n        });\n        \n        utterance.onend = () => {\n          // Only process end event for the current request\n          if (utterance.requestId === currentRequestId.current) {\n            Logger.info('Speech synthesis completed', { requestId: utterance.requestId });\n            isSpeaking.current = false;\n            currentRequestId.current = null;\n            if (isMounted.current && onSpeechEnd) onSpeechEnd();\n          } else {\n            Logger.info('Ignoring completed event for outdated speech request', { \n              requestId: utterance.requestId,\n              currentRequestId: currentRequestId.current\n            });\n          }\n        };\n        \n        utterance.onerror = (error) => {\n          Logger.error('Speech synthesis error:', error);\n          isSpeaking.current = false;\n          currentRequestId.current = null;\n        };\n        \n        // Set rate slightly slower for better comprehension\n        utterance.rate = 0.9;\n        \n        // Start speaking\n        window.speechSynthesis.speak(utterance);\n      } catch (error) {\n        Logger.error('Failed to start speech synthesis:', error);\n        isSpeaking.current = false;\n        currentRequestId.current = null;\n      }\n    }, 100);\n  }, [initSpeechSynthesis, cancelSpeech, onSpeechEnd]);\n\n  // Effect for initial speech and cleanup\n  useEffect(() => {\n    // Set mounted flag\n    isMounted.current = true;\n    \n    // Initialize speech synthesis\n    initSpeechSynthesis();\n    \n    // Cleanup function\n    return () => {\n      isMounted.current = false;\n      // Cancel any ongoing speech when component unmounts\n      cancelSpeech();\n    };\n  }, [initSpeechSynthesis, cancelSpeech]);\n\n  // Effect to handle text changes with proper cleanup\n  useEffect(() => {\n    if (autoSpeak && text) {\n      // If text changed, cancel any current speech and speak the new text\n      cancelSpeech();\n      \n      // Small delay to ensure cancellation is complete\n      setTimeout(() => {\n        speak(text);\n      }, 150);\n    }\n    \n    // If text is cleared, cancel any ongoing speech\n    if (!text) {\n      cancelSpeech();\n    }\n  }, [text, autoSpeak, speak, cancelSpeech]);\n\n  return null; // This is a non-visual component\n};\n\nexport default SpeechHandler;"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"var _s = $RefreshSig$();\n// frontend/src/components/SpeechHandler.js\nimport React, { useEffect, useCallback } from 'react';\nimport Logger from '../utils/logger';\nconst SpeechHandler = ({\n  text,\n  onSpeechEnd,\n  autoSpeak = true\n}) => {\n  _s();\n  const processTextForSpeech = text => {\n    // If the text looks like JSON, try to extract useful parts\n    if (text && (text.includes('{') || text.includes('```'))) {\n      try {\n        // Clean any markdown formatting\n        const cleanedText = text.replace(/```json/g, '').replace(/```/g, '').trim();\n\n        // Try to parse as JSON\n        const jsonData = JSON.parse(cleanedText);\n\n        // Extract human-readable content based on available fields\n        let speechText = '';\n        if (jsonData.answer) {\n          speechText += jsonData.answer + ' ';\n        }\n        if (jsonData.details) {\n          speechText += jsonData.details + ' ';\n        }\n        if (jsonData.feedback) {\n          speechText += jsonData.feedback + ' ';\n        }\n        if (jsonData.warnings && jsonData.warnings.length > 0) {\n          speechText += 'Warnings: ' + jsonData.warnings.join('. ') + ' ';\n        }\n        if (jsonData.recommendations && jsonData.recommendations.length > 0) {\n          speechText += 'Recommendations: ' + jsonData.recommendations.join('. ') + ' ';\n        }\n        if (jsonData.nextSteps && jsonData.nextSteps.length > 0) {\n          speechText += 'Next steps: ' + jsonData.nextSteps.join('. ') + ' ';\n        }\n        return speechText.trim() || text;\n      } catch (error) {\n        Logger.error('Failed to parse JSON for speech:', error);\n        return text;\n      }\n    }\n    return text;\n  };\n  const speak = useCallback(rawText => {\n    if (!rawText) return;\n\n    // Process the text to make it suitable for speech\n    const processedText = processTextForSpeech(rawText);\n\n    // Cancel any ongoing speech\n    window.speechSynthesis.cancel();\n    const utterance = new SpeechSynthesisUtterance(processedText);\n\n    // Log the speech start\n    Logger.info('Starting speech synthesis:', {\n      originalLength: rawText.length,\n      processedLength: processedText.length,\n      processedText: processedText.slice(0, 100) + (processedText.length > 100 ? '...' : '')\n    });\n    utterance.onend = () => {\n      Logger.info('Speech synthesis completed');\n      if (onSpeechEnd) onSpeechEnd();\n    };\n    utterance.onerror = error => {\n      Logger.error('Speech synthesis error:', error);\n    };\n    window.speechSynthesis.speak(utterance);\n  }, [onSpeechEnd]);\n  useEffect(() => {\n    if (autoSpeak && text) {\n      speak(text);\n    }\n  }, [text, autoSpeak, speak]);\n  return null; // This is a non-visual component\n};\n_s(SpeechHandler, \"keiNL/YxH3ny6bq30yRTktUG5QE=\");\n_c = SpeechHandler;\nexport default SpeechHandler;\nvar _c;\n$RefreshReg$(_c, \"SpeechHandler\");","map":{"version":3,"names":["React","useEffect","useCallback","Logger","SpeechHandler","text","onSpeechEnd","autoSpeak","_s","processTextForSpeech","includes","cleanedText","replace","trim","jsonData","JSON","parse","speechText","answer","details","feedback","warnings","length","join","recommendations","nextSteps","error","speak","rawText","processedText","window","speechSynthesis","cancel","utterance","SpeechSynthesisUtterance","info","originalLength","processedLength","slice","onend","onerror","_c","$RefreshReg$"],"sources":["/Users/manmohan/drone-assembly-ai/frontend/src/components/SpeechHandler.js"],"sourcesContent":["// frontend/src/components/SpeechHandler.js\nimport React, { useEffect, useCallback } from 'react';\nimport Logger from '../utils/logger';\n\nconst SpeechHandler = ({ text, onSpeechEnd, autoSpeak = true }) => {\n  const processTextForSpeech = (text) => {\n    // If the text looks like JSON, try to extract useful parts\n    if (text && (text.includes('{') || text.includes('```'))) {\n      try {\n        // Clean any markdown formatting\n        const cleanedText = text\n          .replace(/```json/g, '')\n          .replace(/```/g, '')\n          .trim();\n          \n        // Try to parse as JSON\n        const jsonData = JSON.parse(cleanedText);\n        \n        // Extract human-readable content based on available fields\n        let speechText = '';\n        \n        if (jsonData.answer) {\n          speechText += jsonData.answer + ' ';\n        }\n        \n        if (jsonData.details) {\n          speechText += jsonData.details + ' ';\n        }\n        \n        if (jsonData.feedback) {\n          speechText += jsonData.feedback + ' ';\n        }\n        \n        if (jsonData.warnings && jsonData.warnings.length > 0) {\n          speechText += 'Warnings: ' + jsonData.warnings.join('. ') + ' ';\n        }\n        \n        if (jsonData.recommendations && jsonData.recommendations.length > 0) {\n          speechText += 'Recommendations: ' + jsonData.recommendations.join('. ') + ' ';\n        }\n        \n        if (jsonData.nextSteps && jsonData.nextSteps.length > 0) {\n          speechText += 'Next steps: ' + jsonData.nextSteps.join('. ') + ' ';\n        }\n        \n        return speechText.trim() || text;\n      } catch (error) {\n        Logger.error('Failed to parse JSON for speech:', error);\n        return text;\n      }\n    }\n    \n    return text;\n  };\n\n  const speak = useCallback((rawText) => {\n    if (!rawText) return;\n  \n    // Process the text to make it suitable for speech\n    const processedText = processTextForSpeech(rawText);\n    \n    // Cancel any ongoing speech\n    window.speechSynthesis.cancel();\n\n    const utterance = new SpeechSynthesisUtterance(processedText);\n    \n    // Log the speech start\n    Logger.info('Starting speech synthesis:', { \n      originalLength: rawText.length,\n      processedLength: processedText.length,\n      processedText: processedText.slice(0, 100) + (processedText.length > 100 ? '...' : '')\n    });\n    \n    utterance.onend = () => {\n      Logger.info('Speech synthesis completed');\n      if (onSpeechEnd) onSpeechEnd();\n    };\n\n    utterance.onerror = (error) => {\n      Logger.error('Speech synthesis error:', error);\n    };\n\n    window.speechSynthesis.speak(utterance);\n  }, [onSpeechEnd]);\n\n  useEffect(() => {\n    if (autoSpeak && text) {\n      speak(text);\n    }\n  }, [text, autoSpeak, speak]);\n\n  return null; // This is a non-visual component\n};\n\nexport default SpeechHandler;"],"mappings":";AAAA;AACA,OAAOA,KAAK,IAAIC,SAAS,EAAEC,WAAW,QAAQ,OAAO;AACrD,OAAOC,MAAM,MAAM,iBAAiB;AAEpC,MAAMC,aAAa,GAAGA,CAAC;EAAEC,IAAI;EAAEC,WAAW;EAAEC,SAAS,GAAG;AAAK,CAAC,KAAK;EAAAC,EAAA;EACjE,MAAMC,oBAAoB,GAAIJ,IAAI,IAAK;IACrC;IACA,IAAIA,IAAI,KAAKA,IAAI,CAACK,QAAQ,CAAC,GAAG,CAAC,IAAIL,IAAI,CAACK,QAAQ,CAAC,KAAK,CAAC,CAAC,EAAE;MACxD,IAAI;QACF;QACA,MAAMC,WAAW,GAAGN,IAAI,CACrBO,OAAO,CAAC,UAAU,EAAE,EAAE,CAAC,CACvBA,OAAO,CAAC,MAAM,EAAE,EAAE,CAAC,CACnBC,IAAI,CAAC,CAAC;;QAET;QACA,MAAMC,QAAQ,GAAGC,IAAI,CAACC,KAAK,CAACL,WAAW,CAAC;;QAExC;QACA,IAAIM,UAAU,GAAG,EAAE;QAEnB,IAAIH,QAAQ,CAACI,MAAM,EAAE;UACnBD,UAAU,IAAIH,QAAQ,CAACI,MAAM,GAAG,GAAG;QACrC;QAEA,IAAIJ,QAAQ,CAACK,OAAO,EAAE;UACpBF,UAAU,IAAIH,QAAQ,CAACK,OAAO,GAAG,GAAG;QACtC;QAEA,IAAIL,QAAQ,CAACM,QAAQ,EAAE;UACrBH,UAAU,IAAIH,QAAQ,CAACM,QAAQ,GAAG,GAAG;QACvC;QAEA,IAAIN,QAAQ,CAACO,QAAQ,IAAIP,QAAQ,CAACO,QAAQ,CAACC,MAAM,GAAG,CAAC,EAAE;UACrDL,UAAU,IAAI,YAAY,GAAGH,QAAQ,CAACO,QAAQ,CAACE,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG;QACjE;QAEA,IAAIT,QAAQ,CAACU,eAAe,IAAIV,QAAQ,CAACU,eAAe,CAACF,MAAM,GAAG,CAAC,EAAE;UACnEL,UAAU,IAAI,mBAAmB,GAAGH,QAAQ,CAACU,eAAe,CAACD,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG;QAC/E;QAEA,IAAIT,QAAQ,CAACW,SAAS,IAAIX,QAAQ,CAACW,SAAS,CAACH,MAAM,GAAG,CAAC,EAAE;UACvDL,UAAU,IAAI,cAAc,GAAGH,QAAQ,CAACW,SAAS,CAACF,IAAI,CAAC,IAAI,CAAC,GAAG,GAAG;QACpE;QAEA,OAAON,UAAU,CAACJ,IAAI,CAAC,CAAC,IAAIR,IAAI;MAClC,CAAC,CAAC,OAAOqB,KAAK,EAAE;QACdvB,MAAM,CAACuB,KAAK,CAAC,kCAAkC,EAAEA,KAAK,CAAC;QACvD,OAAOrB,IAAI;MACb;IACF;IAEA,OAAOA,IAAI;EACb,CAAC;EAED,MAAMsB,KAAK,GAAGzB,WAAW,CAAE0B,OAAO,IAAK;IACrC,IAAI,CAACA,OAAO,EAAE;;IAEd;IACA,MAAMC,aAAa,GAAGpB,oBAAoB,CAACmB,OAAO,CAAC;;IAEnD;IACAE,MAAM,CAACC,eAAe,CAACC,MAAM,CAAC,CAAC;IAE/B,MAAMC,SAAS,GAAG,IAAIC,wBAAwB,CAACL,aAAa,CAAC;;IAE7D;IACA1B,MAAM,CAACgC,IAAI,CAAC,4BAA4B,EAAE;MACxCC,cAAc,EAAER,OAAO,CAACN,MAAM;MAC9Be,eAAe,EAAER,aAAa,CAACP,MAAM;MACrCO,aAAa,EAAEA,aAAa,CAACS,KAAK,CAAC,CAAC,EAAE,GAAG,CAAC,IAAIT,aAAa,CAACP,MAAM,GAAG,GAAG,GAAG,KAAK,GAAG,EAAE;IACvF,CAAC,CAAC;IAEFW,SAAS,CAACM,KAAK,GAAG,MAAM;MACtBpC,MAAM,CAACgC,IAAI,CAAC,4BAA4B,CAAC;MACzC,IAAI7B,WAAW,EAAEA,WAAW,CAAC,CAAC;IAChC,CAAC;IAED2B,SAAS,CAACO,OAAO,GAAId,KAAK,IAAK;MAC7BvB,MAAM,CAACuB,KAAK,CAAC,yBAAyB,EAAEA,KAAK,CAAC;IAChD,CAAC;IAEDI,MAAM,CAACC,eAAe,CAACJ,KAAK,CAACM,SAAS,CAAC;EACzC,CAAC,EAAE,CAAC3B,WAAW,CAAC,CAAC;EAEjBL,SAAS,CAAC,MAAM;IACd,IAAIM,SAAS,IAAIF,IAAI,EAAE;MACrBsB,KAAK,CAACtB,IAAI,CAAC;IACb;EACF,CAAC,EAAE,CAACA,IAAI,EAAEE,SAAS,EAAEoB,KAAK,CAAC,CAAC;EAE5B,OAAO,IAAI,CAAC,CAAC;AACf,CAAC;AAACnB,EAAA,CAxFIJ,aAAa;AAAAqC,EAAA,GAAbrC,aAAa;AA0FnB,eAAeA,aAAa;AAAC,IAAAqC,EAAA;AAAAC,YAAA,CAAAD,EAAA","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}